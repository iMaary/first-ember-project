"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addonV1Shim = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const shared_internals_1 = require("@embroider/shared-internals");
const broccoli_funnel_1 = __importDefault(require("broccoli-funnel"));
const semver_1 = require("semver");
function addonMeta(pkgJSON) {
    let meta = pkgJSON['ember-addon'];
    if ((meta === null || meta === void 0 ? void 0 : meta.version) !== 2 || (meta === null || meta === void 0 ? void 0 : meta.type) !== 'addon') {
        throw new Error(`did not find valid v2 addon metadata in ${pkgJSON.name}`);
    }
    return meta;
}
function addonV1Shim(directory, options = {}) {
    let pkg = JSON.parse((0, fs_1.readFileSync)((0, path_1.resolve)(directory, './package.json'), 'utf8'));
    let meta = addonMeta(pkg);
    let disabled = false;
    const rootTrees = new WeakMap();
    function rootTree(addonInstance) {
        let tree = rootTrees.get(addonInstance);
        if (!tree) {
            tree = addonInstance.treeGenerator(directory);
            rootTrees.set(addonInstance, tree);
        }
        return tree;
    }
    return {
        name: pkg.name,
        included(...args) {
            var _a, _b, _c;
            if (((_b = (_a = this.parent.pkg['ember-addon']) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : 1) < 2) {
                let autoImportVersion = (_c = this.parent.addons.find((a) => a.name === 'ember-auto-import')) === null || _c === void 0 ? void 0 : _c.pkg.version;
                if (!autoImportVersion) {
                    throw new Error(`${this.parent.name} needs to depend on ember-auto-import in order to use ${this.name}`);
                }
                if (!(0, semver_1.satisfies)(autoImportVersion, '>=2.0.0-alpha.0', {
                    includePrerelease: true,
                })) {
                    throw new Error(`${this.parent.name} has ember-auto-import ${autoImportVersion} which is not new enough to use ${this.name}. It needs to upgrade to >=2.0`);
                }
            }
            let parentOptions;
            if ((0, shared_internals_1.isDeepAddonInstance)(this)) {
                parentOptions = this.parent.options;
            }
            else {
                parentOptions = this.app.options;
            }
            if (options.disabled) {
                disabled = options.disabled(parentOptions);
            }
            // this is here so that our possible exceptions above take precedence over
            // the one that ember-auto-import will also throw if the app doesn't have
            // ember-auto-import
            this._super.included.apply(this, args);
        },
        treeForApp() {
            if (disabled) {
                return undefined;
            }
            let maybeAppJS = meta['app-js'];
            if (maybeAppJS) {
                const appJS = maybeAppJS;
                return (0, broccoli_funnel_1.default)(rootTree(this), {
                    files: Object.values(appJS),
                    getDestinationPath(relativePath) {
                        for (let [exteriorName, interiorName] of Object.entries(appJS)) {
                            if (relativePath === interiorName) {
                                return exteriorName;
                            }
                        }
                        throw new Error(`bug in addonV1Shim, no match for ${relativePath} in ${JSON.stringify(appJS)}`);
                    },
                });
            }
        },
        treeForAddon() {
            // this never goes through broccoli -- it's always pulled into the app via
            // ember-auto-import, as needed. This means it always benefits from
            // tree-shaking.
            return undefined;
        },
        treeForPublic() {
            if (disabled) {
                return undefined;
            }
            let maybeAssets = meta['public-assets'];
            if (maybeAssets) {
                const assets = maybeAssets;
                return (0, broccoli_funnel_1.default)(rootTree(this), {
                    files: Object.keys(assets),
                    getDestinationPath(relativePath) {
                        for (let [interiorName, exteriorName] of Object.entries(assets)) {
                            if (relativePath === interiorName) {
                                return exteriorName;
                            }
                        }
                        throw new Error(`bug in addonV1Shim, no match for ${relativePath} in ${JSON.stringify(assets)}`);
                    },
                });
            }
        },
        isDevelopingAddon() {
            // if the app is inside our own directory, we must be under development.
            // This setting controls whether ember-cli will watch for changes in the
            // broccoli trees we expose, but it doesn't have any control over our
            // files that get auto-imported into the app. For that, you should use
            // ember-auto-import's watchDependencies option (and this should become
            // part of the blueprint for test apps).
            let appInstance = this._findHost();
            return isInside(directory, appInstance.project.root);
        },
    };
}
exports.addonV1Shim = addonV1Shim;
function isInside(parentDir, otherDir) {
    let rel = (0, path_1.relative)(parentDir, otherDir);
    return Boolean(rel) && !rel.startsWith('..') && !(0, path_1.isAbsolute)(rel);
}
//# sourceMappingURL=index.js.map